<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <title>P4 - Amazon Warehouse</title>
    <!-- Enlace al archivo CSS -->
    <link rel="stylesheet" href="/assets/css/styles.css">
    <!-- Apple icons y favicons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
</head>
<body class="">
    <header>
        <h1>SERVICE ROBOTICS</h1>
    </header>
    <main>
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">P4 - Amazon Warehouse</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-05-11T07:49:08+02:00" itemprop="datePublished">Nov 25, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="practice-3-integration-and-study-of-dynamics-in-gazebo-and-ros2">Practice 4: SERVICE ROBOTICS</h2>

<h3 id="objective">Objective</h3>
<p>
In this practice I developed a program that allows a holonomic/Ackerman logistics robot to autonomously pick up and deliver warehouse shelves inside a simulated Amazon environment.
Our goal was to compute the shortest valid trajectory, follow it safely, manipulate shelves, and update the map accordingly.
</p>

<h3 id="coordinate-transformation">Coordinate Transformation</h3>
<p>
To convert robot positions between Gazebo coordinates and the map image, I reused the same method from Practice 1: selecting several corresponding points in both frames and computing a 2D transformation using the least squares method. With this transformation matrix, I can reliably move between Gazebo meters and map pixels, ensuring that the OMPL planner and the robot controller operate in sync.
</p>

<h3 id="map-loading-and-binarization">Map Loading and Binarization</h3>
<p>
I began by loading the warehouse map in grayscale and converting it into a binary occupancy grid. Using a threshold, I classified each pixel as free (1) or occupied (0). This processed map then served as the state-validity reference for all OMPL path planning.
</p>

<h3 id="shelves">Shelves</h3>
<p>
To manage the interaction with the shelves, I implemented two main actions: picking up and placing them. When the robot reaches the shelf, I first align its orientation and then execute the lifting action. At that moment, I also update the map by removing the shelf's footprint so the planner considers that area free. While the shelf is being carried, I increase the robot's effective radius to reflect the larger occupied space and ensure safe collision checking. When I reach the delivery zone, I realign again, lower the shelf, and write its footprint back onto the map. The robot then returns to its normal size and proceeds to the next shelf.
</p>

<h3 id="state-machine-and-behavior">State Machine and Behavior</h3>

<p>
I structured the robot’s shelf-handling logic as a finite state machine, allowing it to execute each task in a clear and ordered sequence:
</p>

<ol>
  <li><strong>GO_WP:</strong> The robot follows the planned path toward the target waypoint, using OMPL-generated waypoints for navigation.</li>
  <li><strong>ALIGN:</strong> Once near the goal, the robot rotates to match the required orientation before interacting with the shelf or placing it.</li>
  <li><strong>UP_SHELVE:</strong> If the robot is picking up a shelf, it lifts it, increases its effective radius, and removes the shelf's footprint from the map.</li>
  <li><strong>DOWN_SHELVE:</strong> When delivering, the robot lowers the shelf, restores its normal size, and writes the shelf's footprint back onto the map.</li>
</ol>
<p>
After each pickup or drop-off, the system resets the planner and transitions to the next target until all shelves are processed.
</p>

<h3 id="holonomic">Holonomic</h3>

<h2 id="ompl">OMPL Planning</h2>
<p>
For path planning, I used OMPL with an SE2 state space, allowing the planner to consider both position and orientation. I defined the map boundaries as the space limits and implemented a custom validity checker that reads directly from the binary map. This checker rejects any state that falls outside the map or inside an obstacle, and it adapts the robot’s collision radius depending on whether it is carrying a shelf. Once validity was defined, I created the planning problem by setting the start and goal states in pixel coordinates, and used RRTstar as the planner. After OMPL finds a solution, I extract the path from the returned matrix string, convert it into a numpy array, and visualize it in the interface for execution.
</p>

<h2 id="reactive-controller">Reactive Controller</h2>
<p>
To follow each waypoint smoothly, I implemented a reactive controller based on a PID regulation of the angular error. First, I compute the desired heading by taking the angle between the robot’s current position and the target waypoint. Then I calculate the angular difference, this error feeds a PID controller that outputs the angular velocity, allowing the robot to rotate precisely toward the goal. The linear velocity depends on the alignment: if the angular error is large, the robot stops and only rotates; once aligned, it moves forward, adapting the speed based on distance to the waypoint and whether it is carrying a shelf (in which case it moves more slowly and uses different PID gains). This reactive layer ensures stable motion, smooth turns, and safe navigation even before consulting the next waypoint.
</p>

<h3 id="ackermann">Ackermann</h3>

<h2 id="ompl">OMPL Planning</h2>
<p>
For the Ackermann robot, I implemented planning using a <strong>Reeds-Shepp state space</strong>, which allows the robot to move both forward and backward while respecting a minimum turning radius. This makes the planner suitable for car-like, non-holonomic vehicles. I defined the isStateValid() function that checks a rotated bounding rectangle around the robot or shelf at each candidate state, ensuring the path does not collide with obstacles and that the robot maintains safe clearance. The start and goal states include specific orientations; for the goal, I set a fixed yaw so the robot is properly aligned to pick up the shelf when it arrives. After RRTstar finds a solution, I interpolate the path using points, producing a smooth trajectory that can be followed by the reactive controller and visualized in the interface.
</p>

<h2 id="ackermann-controller">Reactive Controller</h2>
<p>
The reactive controller was adapted to handle Ackermann kinematics. I calculate the angular error toward the waypoint as before, but I also check whether the waypoint is in front or behind the robot. If the waypoint is behind, the robot drives in reverse. Linear and angular velocities are computed using a PID controller for rotation, but forward and backward speeds are adjusted based on alignment and distance.
</p>

<h3 id="results-and-observations">Results and Observations</h3>
<p>
During the experiments, I observed that the shelves tend to slide slightly while being carried due to the simulation physics, which prevents them from staying perfectly aligned. As a result, when the robot moves away after placing a shelf and starts approaching the next one, it can occasionally collide slightly with the shelf it just delivered. This happens because, when updating the map, we always assume the shelf is perfectly aligned and do not track any rotation that might have occurred during transport.
</p>

<ol>
  <li><strong>Holonomic:</strong><br>
  <section id="video-section">
        <div class="video-container">
                <video src="/assets/videos/holonomic_x2.webm" controls width="600"></video>
        </div>
</section>
</li>

  <li><strong>Ackermann:</strong><br>
  <section id="video-section">
        <div class="video-container">
                <video src="/assets/videos/ackerman_x2.webm" controls width="600"></video>
        </div>
</section>
</li>
</ol>

  </div><a class="u-url" href="/jekyll/update/2025/11/25/Amazon-Warehouse.html" hidden></a>
</article>

    </main>
    <footer>
        <p>&copy; MOBILE AND SERVICE ROBOTICS</p>
    </footer>
</body>
</html>
